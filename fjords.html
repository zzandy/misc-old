<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta charset="utf-8" />
    <title></title>
</head>

<body>
    <script type="text/javascript">
        function addCanvas(w, h) {
            const canvas = document.createElement('canvas');

            canvas.width = w;
            canvas.height = h;

            document.body.appendChild(canvas);
            return canvas.getContext('2d');
        }
    </script>
    <script type="text/javascript">
        //const colors = ['#FFD300', '#002366', '#C80815'];
        const colors = ['#8fca32', '#0862bf', '#f7f4e6'];
        const secondary = [1, 2];
        const sq32 = Math.sqrt(3) / 2;
        const tau = Math.PI * 2;

        const tile = [0, 0, 0, 0, 0, 0];
        const tiles = [];

        addTile(tile);

        for (let i = 1; i < 6; ++i) {
            place(tile, i, 6);
        }

        function place(tile, from, to) {
            if (from >= to) return;

            for (let c of secondary) {
                let clone = tile.slice();
                for (let i = from; i < to; ++i) {
                    clone[i] = c;
                }

                addTile(clone);

                for (let i = 2; i < from; ++i)
                    place(clone, 1, i)

                for (let i = 2; i < from; ++i)
                    place(clone, i, from - 1);
            }
        }

        function canonical(tile) {
            let tiles = [tile];
            let clone = tile;
            for (let i = 1; i < 6; ++i) {
                clone = clone.slice();
                clone.unshift(clone.pop());
                tiles.push(clone);
            }

            tiles.sort(byScore);

            return tiles[0];
        }

        function byScore(a, b) {
            return score(b) - score(a);
        }

        function score(tile) {
            const s = tile.reduce((a, t) => {

                if (t != 0 && t < a.max) ++a.inv;

                a.max = Math.max(a.max, t);
                if (a.max == 0) ++a.max0;
                return a;
            }, { max0: 0, max: 0, inv: 0 });

            return s.max0 - s.inv * 2;
        }

        console.log(`${tiles.length} total`)

        tiles.sort(byScore);
        tiles.map(draw);

        function addTile(tile) {
            tile = canonical(tile);
            if (!tiles.some(t => t.every((c, i) => c == tile[i])))
                tiles.push(tile)
        }

        function draw(tile) {
            const s = 144;
            const ctx = addCanvas(s, s)

            ctx.translate(s / 2, s / 2);

            ctx.save();
            ctx.beginPath();
            for (let i = 0; i < 6; ++i) {
                if (i == 0) ctx.moveTo(0, s / 2);
                else ctx.lineTo(0, s / 2);

                ctx.rotate(tau / 6);
            }
            ctx.restore();

            ctx.fillStyle = colors[0];
            ctx.fill();

            ctx.save();

            let prev = 0;
            let a = 3 * tau / 12;
            let start = a;
            const r = s / 2;
            const h = sq32 * r;
            const c = s / 4;
            const cos = Math.cos;
            const sin = Math.sin;

            for (let i = 1; i < 7; ++i) {
                let next = tile[i % 6];

                if (prev != 0) {
                    ctx.lineTo(r * cos(a), r * sin(a));
                }

                a += tau / 12;

                if (prev != next) {
                    if (prev != 0) {
                        ctx.lineTo(h * cos(a), h * sin(a));
                        if (a - start >= tau / 3) {
                            const b = (a + start) / 2;
                            const p = [c * cos(b), c * sin(b)]

                            ctx.bezierCurveTo(c * cos(a), c * sin(a), p[0] + c * cos(b + tau / 4) / 2, p[1] + c * sin(b + tau / 4) / 2, p[0], p[1]);
                            ctx.bezierCurveTo(p[0] - c * cos(b + tau / 4) / 2, p[1] - c * sin(b + tau / 4) / 2, c * cos(start), c * sin(start), h * cos(start), h * sin(start));
                        }
                        else
                            ctx.bezierCurveTo(c * cos(a), c * sin(a), c * cos(start), c * sin(start), h * cos(start), h * sin(start));

                        ctx.closePath();
                        ctx.fillStyle = colors[prev];
                        ctx.fill();
                    }
                    else {
                        ctx.beginPath();
                        start = a;
                        ctx.moveTo(h * cos(a), h * sin(a));
                    }
                }

                a += tau / 12;

                prev = next;
            }
        }

    </script>
</body>

</html>