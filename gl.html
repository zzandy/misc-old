<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta charset="utf-8" />
    <title></title>
    <style type="text/css">

    </style>
</head>

<body>
    <script id="vertex" type="x-shader/x-vertex">
        attribute vec4 a_position;
        attribute vec4 a_color;
        uniform mat4 u_view;
        uniform mat4 u_trans;
        varying vec4 v_color;

        void main(){
        gl_Position = u_view * u_trans * a_position;
        v_color = a_color;
        }
    </script>

    <script id="fragment" type="x-shader/x-fragment">
        precision highp float;
        varying vec4 v_color;

        void main() {
        gl_FragColor = v_color;
        }
    </script>

    <!-- matrices -->
    <script type="text/javascript">

        var iden3 = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        var iden4 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

        function mul33(a, b) {
            return [
                a[0] * b[0] + a[1] * b[3] + a[2] * b[6],
                a[0] * b[1] + a[1] * b[4] + a[2] * b[7],
                a[0] * b[2] + a[1] * b[5] + a[2] * b[8],

                a[3] * b[0] + a[4] * b[3] + a[5] * b[6],
                a[3] * b[1] + a[4] * b[4] + a[5] * b[7],
                a[3] * b[2] + a[4] * b[5] + a[5] * b[8],

                a[6] * b[0] + a[7] * b[3] + a[8] * b[6],
                a[6] * b[1] + a[7] * b[4] + a[8] * b[7],
                a[6] * b[2] + a[7] * b[5] + a[8] * b[8],
            ];
        }


        function mul44v(m, v) {
            return [
                m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3] * v[3],
                m[4] * v[0] + m[5] * v[1] + m[6] * v[2] + m[7] * v[3],
                m[8] * v[0] + m[9] * v[1] + m[10] * v[2] + m[11] * v[3],
                m[12] * v[0] + m[13] * v[1] + m[14] * v[2] + m[15] * v[3]
            ];
        }

        function mul44(a, b) {
            return [
                a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12],
                a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13],
                a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14],
                a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15],

                a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12],
                a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13],
                a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14],
                a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15],

                a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12],
                a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13],
                a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14],
                a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15],

                a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12],
                a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13],
                a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14],
                a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15],
            ];
        }

        function inverse(m) {
            var m00 = m[0 * 4 + 0];
            var m01 = m[0 * 4 + 1];
            var m02 = m[0 * 4 + 2];
            var m03 = m[0 * 4 + 3];
            var m10 = m[1 * 4 + 0];
            var m11 = m[1 * 4 + 1];
            var m12 = m[1 * 4 + 2];
            var m13 = m[1 * 4 + 3];
            var m20 = m[2 * 4 + 0];
            var m21 = m[2 * 4 + 1];
            var m22 = m[2 * 4 + 2];
            var m23 = m[2 * 4 + 3];
            var m30 = m[3 * 4 + 0];
            var m31 = m[3 * 4 + 1];
            var m32 = m[3 * 4 + 2];
            var m33 = m[3 * 4 + 3];
            var tmp_0 = m22 * m33;
            var tmp_1 = m32 * m23;
            var tmp_2 = m12 * m33;
            var tmp_3 = m32 * m13;
            var tmp_4 = m12 * m23;
            var tmp_5 = m22 * m13;
            var tmp_6 = m02 * m33;
            var tmp_7 = m32 * m03;
            var tmp_8 = m02 * m23;
            var tmp_9 = m22 * m03;
            var tmp_10 = m02 * m13;
            var tmp_11 = m12 * m03;
            var tmp_12 = m20 * m31;
            var tmp_13 = m30 * m21;
            var tmp_14 = m10 * m31;
            var tmp_15 = m30 * m11;
            var tmp_16 = m10 * m21;
            var tmp_17 = m20 * m11;
            var tmp_18 = m00 * m31;
            var tmp_19 = m30 * m01;
            var tmp_20 = m00 * m21;
            var tmp_21 = m20 * m01;
            var tmp_22 = m00 * m11;
            var tmp_23 = m10 * m01;

            var t0 = (tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31) -
            (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);
            var t1 = (tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31) -
            (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);
            var t2 = (tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31) -
            (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);
            var t3 = (tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21) -
            (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);

            var d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);

            return [
                d * t0,
                d * t1,
                d * t2,
                d * t3,
                d * ((tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30) -
                (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30)),
                d * ((tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30) -
                (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30)),
                d * ((tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30) -
                (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30)),
                d * ((tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20) -
                (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20)),
                d * ((tmp_12 * m13 + tmp_15 * m23 + tmp_16 * m33) -
                (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33)),
                d * ((tmp_13 * m03 + tmp_18 * m23 + tmp_21 * m33) -
                (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33)),
                d * ((tmp_14 * m03 + tmp_19 * m13 + tmp_22 * m33) -
                (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33)),
                d * ((tmp_17 * m03 + tmp_20 * m13 + tmp_23 * m23) -
                (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23)),
                d * ((tmp_14 * m22 + tmp_17 * m32 + tmp_13 * m12) -
                (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22)),
                d * ((tmp_20 * m32 + tmp_12 * m02 + tmp_19 * m22) -
                (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02)),
                d * ((tmp_18 * m12 + tmp_23 * m32 + tmp_15 * m02) -
                (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12)),
                d * ((tmp_22 * m22 + tmp_16 * m02 + tmp_21 * m12) -
                (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02))
            ];
        }
    </script>

    <!-- 3d transformations -->
    <script type="text/javascript">

        function translate3d(trans) {
            return [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                trans[0], trans[1], trans[2], 1
            ];
        }

        function scale3d(scale) {
            return [
                scale[0], 0, 0, 0,
                0, scale[1], 0, 0,
                0, 0, scale[2], 0,
                0, 0, 0, 1
            ];
        }

        function diff(a, b) {
            return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
        }

        function vectorAngleQuaternion(v, a) {
            var s = Math.sin(a / 2);
            return [s * v[0], s * v[1], s * v[2], Math.cos(a / 2)];
        }

        function rotateAArroundB(a, b, angle, axis) {
            var relative = [a[0] - b[0], a[1] - b[1], a[2] - b[2], 1];
            var r = mul44v(rotate3d(vectorAngleQuaternion(axis, angle)), relative);
            return [b[0] + r[0], b[1] + r[1], b[2] + r[2]];
        }

        function rotate3d(q) {
            var x = q[0];
            var y = q[1];
            var z = q[2];
            var w = q[3] || 1;

            return [
                1 - 2 * y * y - 2 * z * z, 2 * x * y - 2 * z * w, 2 * x * z + 2 * y * w, 0,
                2 * x * y + 2 * z * w, 1 - 2 * x * x - 2 * z * z, 2 * y * z - 2 * x * w, 0,
                2 * x * z - 2 * y * w, 2 * y * z + 2 * x * w, 1 - 2 * x * x - 2 * y * y, 0,
                0, 0, 0, 1
            ];
        }

        function makePerspective(fov, aspect, near, far) {
            var f = Math.tan((Math.PI - fov) / 2);
            var r = 1 / (near - far);

            return [
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (near + far) * r, -1,
                0, 0, near * far * r * 2, 0
            ];
        }

        function mul() {
            return [].reduce.call([].reverse.call(arguments), function (a, b) { return mul44(a, b) });
        }

        function makeProjection3d(view, proj, origin, rv, ra, scales) {
            var scale = scale3d(scales);
            var rot = rotate3d(vectorAngleQuaternion(rv, ra));
            var translate = translate3d(origin);

            return mul(proj, view, rot, scale, translate);
        }

        function projection(cam, pos, rot, scale) {
            return mul(cam, translate3d(pos), rotate3d(rot), scale3d(scale));
        }

        function cross(a, b) {
            return [a[1] * b[2] - a[2] * b[1],
                a[2] * b[0] - a[0] * b[2],
                a[0] * b[1] - a[1] * b[0]];
        }

        var epsilon = 1e-10;
        var tau = 2 * Math.PI;
        var deg = tau / 360;

        function length(a) {
            return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
        }

        function substract(a, b) {
            return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
        }

        function norm(a) {
            var len = length(a);
            return len > epsilon
                ? [a[0] / len, a[1] / len, a[2] / len]
                : [0, 0, 0];
        }

        function lookAt(pos, target, up) {
            var z = norm(substract(pos, target));
            var x = norm(cross(up, z));
            var y = norm(cross(z, x));

            return [
                x[0], x[1], x[2], 0,
                y[0], y[1], y[2], 0,
                z[0], z[1], z[2], 0,
                pos[0], pos[1], pos[2], 1
            ];
        }

    </script>

    <!-- shader loading -->
    <script type="text/javascript">
        var mimeFragmentShader = 'x-shader/x-fragment';
        var mimeVertexShader = 'x-shader/x-vertex';

        function compileShader(gl, shaderSource, shaderType) {
            var shader = gl.createShader(shaderType);
            gl.shaderSource(shader, shaderSource);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
                throw new Error(gl.getShaderInfoLog(shader));

            return shader;
        }

        function createShader(gl, shaderId) {
            var tag = document.getElementById(shaderId);
            if (!tag)
                throw new Error('Shader script tag ' + shaderId + ' not found.');

            var type = null;

            if (tag.type === mimeFragmentShader)
                type = gl.FRAGMENT_SHADER;
            else if (tag.type === mimeVertexShader)
                type = gl.VERTEX_SHADER;
            else throw new Error('Unknown shader type, expected "' + mimeVertexShader + '" or "' + mimeFragmentShader + '", got "' + tag.type + '"');

            return compileShader(gl, tag.text, type);
        }

        function createProgram(gl, vertex, fragment) {
            var program = gl.createProgram();

            gl.attachShader(program, vertex);
            gl.attachShader(program, fragment);

            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS))
                throw new Error(gl.getProgramInfoLog(program));

            return program;
        }

        function createProgramFromScripts(gl, vertexId, fragmentId) {
            var vertex = createShader(gl, vertexId);
            var fragment = createShader(gl, fragmentId);

            return createProgram(gl, vertex, fragment);
        }
    </script>

    <!-- helpers -->
    <script type="text/javascript">
        function rnd(a, b) {

            if (a instanceof Array) {

                return a[(Math.random() * a.length) | 0];

            } else {
                switch (arguments.length) {

                    case 2:
                        return a + Math.random() * (b - a);

                    case 1:
                        return Math.random() * a;

                    default:
                        return Math.random();
                }
            }
        }

        function clamp(v, min, max) {
            return v > max ? max :
                v < min ? min :
                v;
        }

        function makeCanvas() {
            var canvas = document.createElement('canvas');
            canvas.width = document.body.parentElement.clientWidth;
            canvas.height = document.body.parentElement.clientHeight;
            canvas.style.position = 'absolute';
            canvas.style.top = '0';
            canvas.style.left = '0';

            document.body.appendChild(canvas);
            return canvas;
        }

        function makeBox(x, y, z, w, hy, dz) {

            var a = [x, y, z];
            var b = [x + w, y, z];
            var c = [x + w, y, z + dz];
            var d = [x, y, z + dz];
            var e = [x, y + hy, z];
            var f = [x + w, y + hy, z];
            var g = [x + w, y + hy, z + dz];
            var h = [x, y + hy, z + dz];

            function tri(a, b, c) {
                return a.concat(b, c);
            }

            function quad(a, b, c, d) {
                return tri(a, b, c).concat(tri(c, d, a));
            }

            return [].concat(
                quad(b, c, d, a),
                quad(e, a, d, h),
                quad(f, b, a, e),
                quad(g, c, b, f),
                quad(h, d, c, g),
                quad(g, f, e, h)
            );
        }

        function makeDodecahedron2(a) {

            var s3 = Math.sqrt(3);
            var s6 = Math.sqrt(6);

            var z = a * 3 / 2 / s6;
            var x = a / 2;
            var y = a / s3;
            var y2 = a / 2 / s3;
            var z2 = a / s6;
            var z3 = a / 2 / s6;

            var v = [
                [0, 0, -z],
                [-x, -y2, -z2],
                [0, -y, -z3],
                [x, -y2, -z2],
                [x, y2, -z3],
                [0, y, -z2],
                [-x, y2, -z3],
                [-x, -y2, z3],
                [0, -y, z2],
                [x, -y2, z3],
                [x, y2, z2],
                [0, y, z3],
                [-x, y2, z2],
                [0, 0, z]
            ];

            function tri(a, b, c) {
                return a.concat(b, c);
            }

            function quad(a, b, c, d) {
                return tri(v[a], v[b], v[c]).concat(tri(v[c], v[d], v[a]));
            }

            var m = [].concat(
                quad(0, 3, 2, 1),
                quad(0, 5, 4, 3),
                quad(0, 1, 6, 5),
                quad(2, 8, 7, 1),
                quad(2, 3, 9, 8),
                quad(4, 10, 9, 3),
                quad(4, 5, 11, 10),
                quad(6, 12, 11, 5),
                quad(6, 1, 7, 12),
                quad(7, 8, 13, 12),
                quad(9, 10, 13, 8),
                quad(11, 12, 13, 10)
            );

            return m;
        }

        function makeDodecahedron(a){


            var v = [
                [0,0,-2*a],
                [a, a, -a],
                [a, -a, -a],
                [-a, a, -a],
                [-a, -a, -a],

                [0,-2*a,0],
                [0,2*a,0],
                [-2*a,0,0],
                [2*a,0,0],

                [a, a, a],
                [a, -a, a],
                [-a, a, a],
                [-a, -a, a],

                [0,0,2*a]
            ];

            function tri(a, b, c) {
                return a.concat(b, c);
            }

            function quad(a, b, c, d) {
                return tri(v[a], v[b], v[c]).concat(tri(v[c], v[d], v[a]));
            }

            return [].concat(
                quad(0, 1, 8, 2),
                quad(0, 3, 6, 1),
                quad(0, 4, 7, 3),
                quad(0, 2, 5, 4),
                quad(2,8,10,5),
                quad(1,6,9,8),
                quad(3,7,11,6),
                quad(4,5,12,7),

                quad(5,10,13,12),
                quad(8,9,13,10),
                quad(6,11,13,9),
                quad(7,12,13,11)
            );
        }

        function makeHex(origin, side, a, q) {
            var l = 3 * 3 * 6 * (3 * side * side - 3 * side + 1);

            var mesh = new Array(l);

            var sq = Math.sqrt(3) / 2;

            origin = [origin[0] - (side - 1) * a * sq, origin[1] - (side - 1) * a / 2, origin[2]];

            var k = 0;

            var dy = a * (1 - q) / 2;
            var dx = dy / (2 * sq);

            function v(x, y, z) {
                mesh[k++] = origin[0] + x;
                mesh[k++] = origin[1] + y;
                mesh[k++] = origin[2] + z;
            }

            function p(o, a, b, c) {
                v(o[0] + a[0], o[1] + a[1], o[2] + a[2]);
                v(o[0] + b[0], o[1] + b[1], o[2] + b[2]);
                v(o[0] + c[0], o[1] + c[1], o[2] + c[2]);
            }

            for (var i = 0; i < side * 2 - 1; ++i) {
                var j0 = Math.max(0, i - side + 1);
                var jMax = Math.min(side * 2 - 1, i + side);

                for (var j = j0; j < jMax; ++j) {

                    var t = a / 10 * (Math.random() - .5);
                    t = 0;

                    var c = [j * a * sq, i * a - j * a / 2, t];

                    p(c, [0, 0, 5], [dx, dy, 0], [-dx, dy, 0]);
                    p(c, [0, 0, 5], [2 * dx, 0, 0], [dx, dy, 0]);
                    p(c, [0, 0, 5], [dx, -dy, 0], [2 * dx, 0, 0]);
                    p(c, [0, 0, 5], [-dx, -dy, 0], [dx, -dy, 0]);
                    p(c, [0, 0, 5], [-2 * dx, 0, 0], [-dx, -dy, 0]);
                    p(c, [0, 0, 5], [-dx, dy, 0], [-2 * dx, 0, 0]);
                }
            }

            return mesh;
        }

        function makeHexColors(side) {
            var l = 3 * 3 * 6 * (3 * side * side - 3 * side + 1);
            var numhexes = l / 3 / 3 / 6;

            var colors = [];

            for (var i = 0; i < numhexes; ++i) {

                var a = Math.random() * 360;
                var c = hcy(a, 1, .5);

                for (var j = 0; j < 6; ++j) {
                    colors = colors.concat(c,c,c);
                }
            }

            return colors;
        }

        function makeGeometry(w) {

            var axis = 100;
            var small = w / axis;

            return [].concat(

                //x
                makeBox(0, 0, 0, 15 * w, -small, -small),

                //y
                makeBox(0, 0, 0, -small, 15 * w, -small),

                //z
                makeBox(0, 0, 0, -small, -small, 15 * w),
                makeBox(0, 0, 0, w, 7 * w, w),
                makeBox(w, 3 * w, 0, 2 * w, w, w),
                makeBox(2, 6 * w, 0, 3 * w, w, w),
                makeBox(3 * w, 3 * w, 2 * w, w, w, w)
            );

        }

        function makeSameColor(geometry, c) {
            var colors = new Float32Array(geometry.length * 3);

            for (var i = 0; i < geometry.length; ++i) {
                colors[ i *3] = c[0];
                colors[i * 3 + 1] = c[1];
                colors[i * 3 + 2] = c[2];
            }

            return colors;
        }


        function makeColors(geometry) {
            var colors = [];

            var a = Math.random() * 360;
            var b = 20 + Math.random() * 320;
            var side = hcy(a, 1, .5);
            var face = hcy((a + b) % 360, 1, .5);
            var cls = [face, face, face, face, side, side, face, face, side, side,  face, face];

            var red = [1, 0, 0];
            var green = [0, 1, 0];
            var blue = [0, 0, 1];
            var prime = [red, green, blue];

            for (var i = 0; i < geometry.length / 3; ++i) {
                var c = i < 12 * 3 ? c = prime[(i / 12) | 0] : cls[i % cls.length];
                colors = colors.concat(c.concat(c, c));
            }

            return colors;
        }

        function makeQuadColors(geometry, baseHue) {
            var colors = new Float32Array(geometry.length * 3);

            var i = 0;
            while (i < colors.length) {
                var c = baseHue === undefined
                    ? hcy(Math.random() * 360, 1, .5)
                    : hcy(baseHue + 50*(rnd() - .5), 1, .5);

                for (var j = 0; j < 6 && (i + j * 3 < colors.length); ++j) {
                    colors[i + j*3 + 0] = c[0];
                    colors[i + j*3 + 1] = c[1];
                    colors[i + j*3 + 2] = c[2];
                }

                i += 6 * 3;
            }

            return colors;
        }
    </script>

    <!-- Color -->
    <script type="text/javascript">

        // hue Chroma luma
        function hcy2rgb(h, c, y, a) {
            // 601
            var r = .3;
            var g = .59;
            var b = .11;

            var h0 = h;
            h /= 60;

            var k = (1 - Math.abs((h % 2) - 1));

            var K = h < 1 ? r + k * g
                : h < 2 ? g + k * r
                : h < 3 ? g + k * b
                : h < 4 ? b + k * g
                : h < 5 ? b + k * r
                : r + k * b;

            var cmax = 1;

            if (y <= 0 || y >= 1) cmax = 0;
            else cmax *= K < y ? (y - 1) / (K - 1) : K > y ? y / K : 1;
            c = Math.min(c, cmax);

            var x = c * k;
            var rgb = h < 1 ? [c, x, 0]
                : h < 2 ? [x, c, 0]
                : h < 3 ? [0, c, x]
                : h < 4 ? [0, x, c]
                : h < 5 ? [x, 0, c]
                : [c, 0, x];

            var m = y - (r * rgb[0] + g * rgb[1] + b * rgb[2]);

            var rgbdata = [rgb[0] + m, rgb[1] + m, rgb[2] + m];

            return rgbdata;
        }

        function hcy(h, c, y) {

            var k = .1;
            var x = h / 360;
            h = h * (1 - (x < .66 ? 1 : 0) * k * Math.sin(3 * Math.PI * x));
            y *= (1 + .4 * Math.sin(x * 2 * Math.PI));

            return hcy2rgb(h, c, y);
        }

    </script>

    <!-- transitions -->
    <script type="text/javascript">

        function fade(t) {
            return t < 0 ? 0 : t > 1 ? 1 : t * t * t * (t * (t * 6 - 15) + 10);
        }

        function Transition(interval, delta, setter, done) {
            this.interval = interval;
            this.elapsed = 0;
            this.delta = delta;
            this.setter = setter;
            this.done = done;
            this.completed = false;
        }

        Transition.prototype.apply = function (delta) {

            if (this.completed) return;

            if (this.elapsed + delta > this.interval)
                this.delta = this.interval - this.elapsed;

            var q = fade((this.elapsed + delta) / this.interval) - fade(this.elapsed / this.interval);

            this.elapsed += delta;
            this.setter(q * this.delta);

            if (this.elapsed >= this.interval) {
                if (this.done)
                    this.done.call(null);
                this.completed = true;
            }
        }

        var transitions = [];

        function tr(interval, delta, setter, done) {
            transitions.push(new Transition(interval, delta, setter, done));
        }
    </script>

    <!-- Mesh -->
    <script type="text/javascript">
        function Mesh(vertex, fragment, geometry, colors, pos, rotv, rota, scale) {
            this.vertex = vertex;
            this.fragment = fragment;
            this.pos = pos || [0, 0, 0]; // vector3
            this.rotv = rota || [0, 0, 1];
            this.rota = rota || 0;
            this.scale = scale || [1, 1, 1]; // vector3
            this.geometry = new Float32Array(geometry);
            this.colors = new Float32Array(colors);

            this.program = null;
            this.gl = null;
            this.vtxbuffer = null;
            this.colbuffer = null;
            this.pos_attr = null;
            this.color_attr = null;
            this.trans = null;
            this.view = null;
        }

        Mesh.prototype.load = function (gl) {
            this.gl = gl;

            var p = this.program = createProgram(gl,
                this.vertex instanceof String
                ? compileShader(gl, this.vertex, gl.VERTEX_SHADER)
                : this.vertex,
                this.fragment instanceof String
                ? compileShader(gl, this.fragment, gl.FRAGMENT_SHADER)
                : this.fragment);

            gl.useProgram(p);

            this.vtxbuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vtxbuffer);
            gl.bufferData(gl.ARRAY_BUFFER, this.geometry, gl.STATIC_DRAW);

            this.colbuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.colbuffer);
            gl.bufferData(gl.ARRAY_BUFFER, this.colors, gl.STATIC_DRAW);

            this.pos_attr = gl.getAttribLocation(p, 'a_position');
            this.color_attr = gl.getAttribLocation(p, 'a_color');
            this.trans = gl.getUniformLocation(p, 'u_trans');
            this.view = gl.getUniformLocation(p, 'u_view');
        }

        Mesh.prototype.draw = function (cam) {

            var gl = this.gl;
            var p = this.program;

            gl.useProgram(p);

            gl.bindBuffer(gl.ARRAY_BUFFER, this.vtxbuffer);
            gl.enableVertexAttribArray(this.pos_attr);
            gl.vertexAttribPointer(this.pos_attr, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this.colbuffer);
            gl.enableVertexAttribArray(this.color_attr);
            gl.vertexAttribPointer(this.color_attr, 3, gl.FLOAT, false, 0, 0);

            gl.uniformMatrix4fv(this.view, false, cam);
            gl.uniformMatrix4fv(this.trans, false, mul(translate3d(this.pos),
                rotate3d(vectorAngleQuaternion(this.rotv, this.rota)),
                scale3d(this.scale)));

            gl.drawArrays(gl.TRIANGLES, 0, this.geometry.length / 3);
        }
    </script>

    <script type="text/javascript">

        var fov = 80 * deg;

        var cam = new Camera([0, 0, 10],
        [0, 0, 1],
        [0, 0, 10]);

        function Camera(pos, up, lookat) {
            this.pos = pos;
            this.up = up;
            this.lookat = lookat;
        }

        var objects = [];

        function init() {
            var canvas = makeCanvas();
            var gl = canvas.getContext('experimental-webgl');
            gl.clearColor(0,0,0, 1);

            var aspect = canvas.clientWidth / canvas.clientHeight;

            function load(object) {
                object.load(gl);
                objects.push(object);
            }

            var hexSide = 7;
            var hexq = 0;

            var vertex = createShader(gl, 'vertex');
            var fragment = createShader(gl, 'fragment');

            var posAnalytic = [0, 0, 5];
            cam.lookat = posAnalytic;

            (function loadSomeObjects(a, o) {

                var cols = 4;
                var rows = 4;
                var layers = 4;
                
                var s6 = Math.sqrt(6);
                var s3 = Math.sqrt(3);

                var dy = s3 / 2;
                var dz = 2 * a / s6;
                var oyz = a / 2 / s3;


                for (var i = 0; i < rows; ++i)
                    for (var j = 0; j < cols; ++j)
                        for (var k = 0; k < layers; ++k)
                            load(new Mesh(vertex, fragment, g = makeDodecahedron2(a), makeQuadColors(g, rnd(360)),
                            [
                                -cols/2 + o[0] + ((i + (k%3)) % 2) * a / 2 + a * j,
                                -rows/2 + o[1] + a * i * dy - oyz*(k%3),
                                -layers/2 + o[2] + dz * k
                            ]));
            })(5, [0, 0, 0]);

            (function loadGrid() {
                var s = .1;
                var d = 5;
                var w = 4;

                for (var i = 0 - w; i <= w; ++i)
                    for (var j = 0 - w; j <= w; ++j)
                        load(new Mesh(vertex, fragment, g = makeDodecahedron2(s), makeSameColor(g, [.6, .6, .6]), [d * i, d * j, 0]));
            })();

            return function (delta) {
                transitions.forEach(function (transition) { transition.apply(delta) });

                transitions = transitions.filter(function (transition) {
                    return !transition.completed;
                });

                var pr = makePerspective(fov, aspect, 1, 100000);
                var view = inverse(lookAt(cam.pos, cam.lookat, cam.up));

                gl.enable(gl.CULL_FACE);
                gl.enable(gl.DEPTH_TEST);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                var numObj = objects.length;

                while (numObj-- > 0) {
                    objects[numObj].draw(mul44(view, pr));
                }
            }
        }

        var draw = init('canvas');

        var k = 0;

        var time = (new Date()).getTime();

        function tick() {

            var time2 = (new Date()).getTime();
            var delta = time2 - time;
            time = time2;

            draw(delta);

            window.requestAnimationFrame(tick);
        }

        tick();

        function ease(from, to, time, callback) {

            var start = (new Date()).getTime();
            var then = start;

            var update = function() {
                var now = (new Date()).getTime();
                var delta = now - then;
                then = now;

                callback(from + (to - from) * fade((now - start) / time), delta);

                if(now-start<time)
                        window.requestAnimationFrame(update);
            }

            update();
        }

        cam.pos = [50, 0, 10];

        function abs(v) {
            return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
        }

        var controller = {
            k: 1.2,
            qpanh: deg / 12,
            qpanv: deg / 30,
            qorbh: deg / 2,
            qorbv: deg / 10,
            minfov: 2 * deg,
            maxfov: 130 * deg,
            zoom: function(delta) {
                if (delta > 0)
                    fov = clamp(fov * this.k, this.minfov, this.maxfov);
                else if (delta < 0)
                    fov = clamp(fov / this.k, this.minfov, this.maxfov);
            },
            pan: function(dx, dy) {
                cam.lookat = rotateAArroundB(cam.lookat, cam.pos, dx * this.qpanh, cam.up);
                cam.lookat = rotateAArroundB(cam.lookat, cam.pos, dy * this.qpanv, cross(cam.up, diff(cam.pos, cam.lookat)));
            },
            orbit: function(dx, dy) {
                cam.pos = rotateAArroundB(cam.pos, cam.lookat, dx * this.qorbh, cam.up);
                cam.pos = rotateAArroundB(cam.pos, cam.lookat, -dy * this.qorbv, cross(cam.up, diff(cam.pos, cam.lookat)));
            }
        };


        window.addEventListener('wheel', function (e) {
            controller.zoom(e.deltaY);

            e.preventDefault();
        });


        var prevx = null;
        var prevy = null;

        window.addEventListener('mousemove', function (e) {
            var dx, dy;

            if (prevx == null) {
                dx = 0;
                dy = 0;
            } else {
                dx = e.clientX - prevx;
                dy = e.clientY - prevy;
            }

            prevx = e.clientX;
            prevy = e.clientY;

            if(!!(e.buttons & 1))
                controller.pan(dx, dy);
            else if(!!(e.buttons & 2))
                controller.orbit(dx,dy);
        });

        window.addEventListener('contextmenu', function (e) { e.preventDefault() }, true);

    </script>
</body>

</html>