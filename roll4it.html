<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" style="background-color: white;">

<head>
    <meta charset="utf-8" />
    <title>Roll for it!</title>
</head>

<body>
    <script type="text/javascript">
        function addCanvas(w, h, dontAdd) {
            const canvas = document.createElement('canvas');

            canvas.width = w;
            canvas.height = h;

            if (!dontAdd)
                document.body.appendChild(canvas);

            return canvas.getContext('2d');
        }
    </script>
    <script type="text/javascript">
        const frame = [1690, 1100];
        const cardAspect = 0.62;

        const palette = [
            ['hsl(125, 100%, 40%)', 'hsl(105, 90%, 70%)', 'hsl(125, 50%, 80%)', 'hsl(125, 100%, 10%)'],
            ['hsl(350, 100%, 35%)', 'hsl(10, 100%, 70%)', 'hsl(350, 50%, 90%)', 'hsl(350, 100%, 20%)'],
            ['hsl(35, 100%, 50%)', 'hsl(45, 100%, 70%)', 'hsl(35, 50%, 85%)', 'hsl(35, 100%, 20%)'],
            ['hsl(290, 100%, 35%)', 'hsl(270, 100%, 65%)', 'hsl(290, 50%, 85%)', 'hsl(290, 100%, 15%)']
        ];

        const rows = 5; // rows as in for portrait then 2 landscape
        const sides = 2;
        const cols = 4;

        const deck = [
            [1, 2, 3, 4, 5, 6],
            [1, 1, 1, 1, 1, 1],
            [3, 6, 3, 6, 3, 6],
            [5, 5, 5, 5, 5, 5],
            [2, 2, 3, 3, 5, 5],

            [1, 1],
            [2, 2],
            [3, 3],
            [4, 4],
            [5, 5],

            [6, 6],
            [2, 4],
            [1, 3],
            [4, 6],
            [3, 5],

            [1, 2, 3],
            [4, 5, 6],
            [1, 2, 4],
            [2, 3, 6],
            [3, 5, 6],

            [1, 4, 5],
            [2, 4, 6],
            [3, 4, 6],
            [1, 6, 6],
            [2, 4, 5, 5],

            [4, 4, 4, 4],
            [2, 2, 6, 6],
            [1, 3, 4, 4],
            [1, 1, 2, 2],
            [2, 3, 2, 3],
        ];

        deck.sort(() => Math.random() - .5)

        fourOverTwo(frame, cardAspect, deck);

        function fourOverTwo(frame, cardAspect, cards) {
            const w = Math.max(3, (frame[1] * .005) | 0);

            const outer = [0, ((frame[1] - 3 * w) / (1 + cardAspect)) | 0];
            outer[0] = outer[1] * cardAspect | 0;

            const dieSize = outer[0] * .375 | 0;
            const inner = [outer[0] * .9 | 0, (dieSize * 3 + 4 * outer[0] * .05) | 0];

            const radius = [outer[0] / 20, inner[0] / 20];
            const margin = w * 20;

            const ctx = addCanvas(w + cols * outer[0] + cols * w * 2, w + rows * (outer[0] + outer[1]) + rows * (margin + w));

            let pos = 0;
            let row = 0;

            for (let card of cards) {

                if (pos < cols)
                    drawCard(ctx, [w + pos * (2 * w + outer[0]), w + row * (w + margin + outer[0] + outer[1])], card, outer, inner, radius, dieSize);
                else {
                    ctx.save();
                    ctx.translate(w + (pos - cols) * (2 * w + outer[1]), 2 * w - margin + (row + 1) * (w + margin + outer[0] + outer[1]));
                    ctx.rotate(-Math.PI / 2)

                    drawCard(ctx, [0, 0], card, outer, inner, radius, dieSize);
                    ctx.restore();
                }

                if (++pos >= cols + sides) {
                    pos = 0;
                    ++row;
                }
            }
        }

        function drawCard(ctx, pos, dice, outer, inner, radius, dieSize) {
            const colors = palette[dice.length < 3 ? 0 : dice.length > 4 ? 3 : (dice.length - 2)];
            const price = dice.length < 3 ? 2 : dice.length > 4 ? 15 : dice.length == 4 ? 10 : 5;

            const pad = (outer[0] - inner[0]) / 2;
            const priceRad = ((outer[1] - inner[1]) * 1.1) | 0;

            // card
            ctx.save();
            ctx.strokeStyle = colors[3];
            ctx.lineWidth = radius[2] / 3;
            ctx.translate(pos[0], pos[1])

            roundedRect(ctx, 0, 0, outer[0], outer[1], radius[0]);
            ctx.fillStyle = colors[0];
            ctx.fill();
            ctx.stroke();

            roundedRect(ctx, pad, pad, inner[0], inner[1], radius[1]);
            ctx.fillStyle = colors[1];
            ctx.fill();
            ctx.stroke();

            // dice

            let offst = dice.length == 2 ? .25 : dice.length == 3 ? -.4 : 0;
            let offs2 = dice.length == 2 ? .5 : dice.length == 3 ? -.4 : 0;

            let rowLen = dice.length > 3 ? 2 : 1;

            let numRows = (dice.length / rowLen) | 0;
            let diePad = (inner[0] - rowLen * dieSize) / (rowLen + 1);
            let dieVPad = (inner[1] - numRows * dieSize) / (numRows + 1) * (numRows == 2 ? .8 : 1);

            let n = 0;
            for (let die of dice) {
                drawDice(ctx, -dieSize * offst + dieSize * offs2 * n + pad + diePad + n % rowLen * (dieSize + diePad), pad + dieVPad + ((n / rowLen) | 0) * (dieSize + dieVPad), die, dieSize, priceRad);
                ++n;
            }
            // Price circle

            circle(ctx, outer[0] / 2, outer[1] - pad / 2 - priceRad / 2, priceRad / 2);

            ctx.fillStyle = colors[2];
            ctx.fill();
            ctx.stroke();

            ctx.font = ' ' + ((priceRad * 0.9) | 0) + 'px Candara';
            const measure = ctx.measureText(price);

            ctx.fillStyle = colors[3];
            ctx.fillText(price, outer[0] / 2 - measure.width / 2, outer[1] - pad / 2 - priceRad / 2 + measure.actualBoundingBoxAscent / 2);

            ctx.restore();
        }

        function drawDice(ctx, x, y, value, dieSize, priceRad) {
            ctx.save();
            ctx.translate(x, y)

            roundedRect(ctx, 0, 0, dieSize, dieSize, dieSize / 10);
            ctx.fillStyle = "ivory";
            ctx.fill()

            ctx.lineWidth = 2
            ctx.strokeStyle = 'black';
            ctx.stroke();

            ctx.fillStyle = 'black';

            if (value % 2 == 1) {
                circle(ctx, dieSize / 2, dieSize / 2, dieSize / 10)
                ctx.fill();
            }

            const k = 5;

            if (value > 1) {
                circle(ctx, dieSize / k, dieSize / k, dieSize / 10)
                ctx.fill();

                circle(ctx, dieSize - dieSize / k, dieSize - dieSize / k, dieSize / 10)
                ctx.fill();
            }

            if (value > 3) {
                circle(ctx, dieSize - dieSize / k, dieSize / k, dieSize / 10)
                ctx.fill();

                circle(ctx, dieSize / k, dieSize - dieSize / k, dieSize / 10)
                ctx.fill();
            }

            if (value == 6) {
                circle(ctx, dieSize / k, dieSize / 2, dieSize / 10)
                ctx.fill();

                circle(ctx, dieSize - dieSize / k, dieSize / 2, dieSize / 10)
                ctx.fill();
            }

            ctx.restore();
        }

        function circle(ctx, x, y, r) {
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.closePath();
        }

        function roundedRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x, y + radius);
            ctx.lineTo(x, y + height - radius);
            ctx.arcTo(x, y + height, x + radius, y + height, radius);
            ctx.lineTo(x + width - radius, y + height);
            ctx.arcTo(x + width, y + height, x + width, y + height - radius, radius);
            ctx.lineTo(x + width, y + radius);
            ctx.arcTo(x + width, y, x + width - radius, y, radius);
            ctx.lineTo(x + radius, y);
            ctx.arcTo(x, y, x, y + radius, radius);
            ctx.closePath();
        }

    </script>
</body>

</html>